import type {
  RunResult,
  TestHistory,
  ErrorCluster,
  Result,
} from '@sorry-currents/core';
import { ok, err, AppError, ErrorCode, clusterErrors } from '@sorry-currents/core';

/**
 * Options for HTML report generation.
 */
export interface HtmlReportOptions {
  readonly title?: string;
  readonly theme?: 'light' | 'dark' | 'auto';
}

/**
 * Full report data assembled by the ReportBuilder.
 */
interface ReportData {
  readonly runResult: RunResult;
  readonly history?: readonly TestHistory[];
  readonly artifactBaseUrl?: string;
  readonly theme: 'light' | 'dark' | 'auto';
  readonly title: string;
  readonly errorClusters: readonly ErrorCluster[];
}

/**
 * Builder for assembling all pieces of a rich HTML report.
 *
 * Usage:
 * ```ts
 * const html = new ReportBuilder()
 *   .withRunResult(merged)
 *   .withHistory(history)
 *   .withArtifacts('/artifacts')
 *   .withTheme('dark')
 *   .build();
 * ```
 */
export class ReportBuilder {
  private runResult: RunResult | undefined;
  private history: readonly TestHistory[] | undefined;
  private artifactBaseUrl: string | undefined;
  private theme: 'light' | 'dark' | 'auto' = 'auto';
  private title = 'sorry-currents Test Report';

  withRunResult(runResult: RunResult): this {
    this.runResult = runResult;
    return this;
  }

  withHistory(history: readonly TestHistory[]): this {
    this.history = history;
    return this;
  }

  withArtifacts(baseUrl: string): this {
    this.artifactBaseUrl = baseUrl;
    return this;
  }

  withTheme(theme: 'light' | 'dark' | 'auto'): this {
    this.theme = theme;
    return this;
  }

  withTitle(title: string): this {
    this.title = title;
    return this;
  }

  build(): Result<string> {
    if (!this.runResult) {
      return err(
        new AppError(
          ErrorCode.SCHEMA_VALIDATION,
          'ReportBuilder requires a RunResult. Call .withRunResult() first.',
        ),
      );
    }

    const errorClusters = clusterErrors(this.runResult.tests);

    const reportData: ReportData = {
      runResult: this.runResult,
      history: this.history,
      artifactBaseUrl: this.artifactBaseUrl,
      theme: this.theme,
      title: this.title,
      errorClusters,
    };

    return ok(renderHtml(reportData));
  }
}

/**
 * Generate a self-contained HTML report from a RunResult.
 * Convenience wrapper around ReportBuilder for simple use cases.
 */
export function generateHtmlReport(
  runResult: RunResult,
  options: HtmlReportOptions = {},
): string {
  const builder = new ReportBuilder()
    .withRunResult(runResult)
    .withTheme(options.theme ?? 'auto')
    .withTitle(options.title ?? 'sorry-currents Test Report');

  const result = builder.build();
  if (!result.ok) {
    // Should never happen since we always provide runResult
    throw new Error(result.error.message);
  }
  return result.value;
}

// ‚îÄ‚îÄ‚îÄ HTML rendering ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function renderHtml(data: ReportData): string {
  const { runResult, history, errorClusters, theme, title, artifactBaseUrl } = data;

  // Prepare embedded JSON data
  const embeddedData = JSON.stringify({
    run: runResult,
    history: history ?? [],
    errorClusters,
    artifactBaseUrl: artifactBaseUrl ?? null,
  });

  return `<!DOCTYPE html>
<html lang="en" data-theme="${theme}">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${escapeHtml(title)}</title>
  <style>${CSS}</style>
</head>
<body>
  <header>
    <h1>${escapeHtml(title)}</h1>
    <div class="run-meta" id="run-meta"></div>
  </header>

  <section class="summary" id="summary"></section>

  <nav class="tabs" id="tabs">
    <button class="tab active" data-tab="tests">Tests</button>
    <button class="tab" data-tab="errors">Error Clusters</button>
    <button class="tab" data-tab="shards">Shards</button>
    <button class="tab" data-tab="flaky">Flaky</button>
    <button class="tab" data-tab="history">History</button>
  </nav>

  <div class="controls">
    <input type="search" id="search" placeholder="Search tests by name, file, or error..." />
    <select id="filter-status">
      <option value="all">All statuses</option>
      <option value="failed">Failed</option>
      <option value="flaky">Flaky</option>
      <option value="passed">Passed</option>
      <option value="skipped">Skipped</option>
    </select>
  </div>

  <main id="content"></main>

  <footer>
    <p>Generated by <strong>sorry-currents</strong> &mdash; free, open-source Playwright test orchestration</p>
  </footer>

  <script>
    const REPORT = ${embeddedData};
    ${JS}
  </script>
</body>
</html>
`;
}

// ‚îÄ‚îÄ‚îÄ CSS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const CSS = `
:root {
  --bg: #ffffff; --bg2: #f8fafc; --fg: #1e293b; --fg2: #64748b;
  --border: #e2e8f0; --hover: #f1f5f9;
  --pass: #22c55e; --pass-bg: #f0fdf4;
  --fail: #ef4444; --fail-bg: #fef2f2;
  --flaky: #f59e0b; --flaky-bg: #fffbeb;
  --skip: #94a3b8; --skip-bg: #f8fafc;
  --blue: #3b82f6; --blue-bg: #eff6ff;
  --radius: 8px;
  --font: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  --mono: ui-monospace, SFMono-Regular, 'SF Mono', Menlo, monospace;
}
@media (prefers-color-scheme: dark) {
  :root[data-theme="auto"] {
    --bg: #0f172a; --bg2: #1e293b; --fg: #e2e8f0; --fg2: #94a3b8;
    --border: #334155; --hover: #1e293b;
    --pass-bg: #052e16; --fail-bg: #450a0a; --flaky-bg: #451a03; --skip-bg: #1e293b; --blue-bg: #172554;
  }
}
[data-theme="dark"] {
  --bg: #0f172a; --bg2: #1e293b; --fg: #e2e8f0; --fg2: #94a3b8;
  --border: #334155; --hover: #1e293b;
  --pass-bg: #052e16; --fail-bg: #450a0a; --flaky-bg: #451a03; --skip-bg: #1e293b; --blue-bg: #172554;
}
* { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: var(--font); background: var(--bg); color: var(--fg); padding: 24px; max-width: 1400px; margin: 0 auto; }
header { margin-bottom: 24px; }
h1 { font-size: 1.5rem; margin-bottom: 4px; }
h2 { font-size: 1.15rem; margin-bottom: 12px; }
.run-meta { font-size: 0.85rem; color: var(--fg2); }

.summary { display: flex; gap: 12px; margin-bottom: 20px; flex-wrap: wrap; }
.stat { padding: 12px 16px; border-radius: var(--radius); background: var(--bg2); border: 1px solid var(--border); min-width: 100px; }
.stat .label { font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.05em; color: var(--fg2); margin-bottom: 2px; }
.stat .value { font-size: 1.5rem; font-weight: 700; }
.stat.pass .value { color: var(--pass); }
.stat.fail .value { color: var(--fail); }
.stat.flaky .value { color: var(--flaky); }
.stat.skip .value { color: var(--skip); }

.tabs { display: flex; gap: 0; margin-bottom: 16px; border-bottom: 2px solid var(--border); }
.tab { background: none; border: none; padding: 8px 16px; cursor: pointer; font-size: 0.9rem; color: var(--fg2); font-family: var(--font); border-bottom: 2px solid transparent; margin-bottom: -2px; }
.tab:hover { color: var(--fg); }
.tab.active { color: var(--blue); border-bottom-color: var(--blue); font-weight: 600; }

.controls { display: flex; gap: 12px; margin-bottom: 16px; flex-wrap: wrap; }
input[type="search"], select {
  padding: 8px 12px; border: 1px solid var(--border); border-radius: var(--radius);
  background: var(--bg); color: var(--fg); font-size: 0.9rem; font-family: var(--font);
}
input[type="search"] { flex: 1; min-width: 200px; }

table { width: 100%; border-collapse: collapse; font-size: 0.9rem; }
th { text-align: left; padding: 8px 12px; border-bottom: 2px solid var(--border); cursor: pointer; user-select: none; white-space: nowrap; color: var(--fg2); font-weight: 600; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.05em; }
th:hover { color: var(--fg); }
th .sort-arrow { margin-left: 4px; font-size: 0.7rem; }
td { padding: 8px 12px; border-bottom: 1px solid var(--border); vertical-align: top; }
tr:hover { background: var(--hover); }

.badge { display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 0.75rem; font-weight: 600; }
.badge-pass { background: var(--pass-bg); color: var(--pass); }
.badge-fail { background: var(--fail-bg); color: var(--fail); }
.badge-flaky { background: var(--flaky-bg); color: var(--flaky); }
.badge-skip { background: var(--skip-bg); color: var(--skip); }
.badge-timeout { background: var(--fail-bg); color: var(--fail); }

.file-path { font-family: var(--mono); font-size: 0.8rem; color: var(--fg2); }
.test-title { font-weight: 500; }
.duration { font-family: var(--mono); font-size: 0.85rem; white-space: nowrap; }
.error-pre { font-family: var(--mono); font-size: 0.8rem; background: var(--bg2); padding: 8px 12px; border-radius: var(--radius); overflow-x: auto; margin-top: 6px; white-space: pre-wrap; word-break: break-word; border: 1px solid var(--border); max-height: 200px; }
.expandable { cursor: pointer; }
.expandable .details { display: none; margin-top: 8px; }
.expandable.open .details { display: block; }

.cluster-card { background: var(--bg2); border: 1px solid var(--border); border-radius: var(--radius); padding: 16px; margin-bottom: 12px; }
.cluster-card h3 { font-size: 0.95rem; margin-bottom: 8px; }
.cluster-meta { font-size: 0.8rem; color: var(--fg2); margin-bottom: 8px; }

.shard-bar-container { display: flex; gap: 8px; align-items: flex-end; height: 200px; margin-bottom: 16px; padding-top: 8px; }
.shard-bar { flex: 1; background: var(--blue); border-radius: 4px 4px 0 0; min-width: 30px; position: relative; display: flex; flex-direction: column; align-items: center; justify-content: flex-end; transition: opacity 0.2s; }
.shard-bar:hover { opacity: 0.8; }
.shard-bar .bar-label { font-size: 0.7rem; color: var(--fg2); text-align: center; margin-top: 4px; position: absolute; bottom: -20px; }
.shard-bar .bar-value { font-size: 0.75rem; font-weight: 600; position: absolute; top: -18px; }
.shard-info { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 12px; margin-top: 28px; }
.shard-card { background: var(--bg2); border: 1px solid var(--border); border-radius: var(--radius); padding: 12px; }
.shard-card h4 { font-size: 0.85rem; margin-bottom: 4px; }
.shard-card .shard-detail { font-size: 0.8rem; color: var(--fg2); }

.trend-spark { display: inline-flex; align-items: flex-end; gap: 1px; height: 20px; vertical-align: middle; }
.trend-spark .bar { width: 3px; background: var(--blue); border-radius: 1px; min-height: 1px; }

.empty-state { text-align: center; padding: 40px; color: var(--fg2); }

footer { margin-top: 40px; padding-top: 16px; border-top: 1px solid var(--border); font-size: 0.8rem; color: var(--fg2); text-align: center; }

@media (max-width: 768px) {
  body { padding: 12px; }
  .summary { gap: 8px; }
  .stat { min-width: 80px; padding: 8px 12px; }
  .stat .value { font-size: 1.2rem; }
  td, th { padding: 6px 8px; }
  .controls { flex-direction: column; }
}
`;

// ‚îÄ‚îÄ‚îÄ JS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const JS = `
(function() {
  const { run, history, errorClusters, artifactBaseUrl } = REPORT;

  // State
  let currentTab = 'tests';
  let searchQuery = '';
  let statusFilter = 'all';
  let sortKey = 'status';
  let sortDir = 'asc';

  // --- Init ---
  renderMeta();
  renderSummary();
  renderContent();
  bindEvents();

  function renderMeta() {
    const meta = document.getElementById('run-meta');
    const d = new Date(run.timestamp);
    const parts = [
      run.environment?.os ? 'OS: ' + run.environment.os : '',
      run.git?.branch ? 'Branch: ' + run.git.branch : '',
      run.git?.commit ? 'Commit: ' + run.git.commit.slice(0, 8) : '',
      'Shards: ' + run.shardCount,
      'Duration: ' + fmtDur(run.duration),
      d.toLocaleString(),
    ].filter(Boolean);
    meta.textContent = parts.join(' ¬∑ ');
  }

  function renderSummary() {
    const el = document.getElementById('summary');
    const stats = [
      { label: 'Total', value: run.totalTests, cls: '' },
      { label: 'Passed', value: run.passedTests, cls: 'pass' },
      { label: 'Failed', value: run.failedTests, cls: 'fail' },
      { label: 'Flaky', value: run.flakyTests, cls: 'flaky' },
      { label: 'Skipped', value: run.skippedTests, cls: 'skip' },
      { label: 'Duration', value: fmtDur(run.duration), cls: '' },
    ];
    el.innerHTML = stats.map(s =>
      '<div class="stat ' + s.cls + '"><div class="label">' + s.label + '</div><div class="value">' + s.value + '</div></div>'
    ).join('');
  }

  function renderContent() {
    const el = document.getElementById('content');
    switch (currentTab) {
      case 'tests': el.innerHTML = renderTestsTab(); break;
      case 'errors': el.innerHTML = renderErrorsTab(); break;
      case 'shards': el.innerHTML = renderShardsTab(); break;
      case 'flaky': el.innerHTML = renderFlakyTab(); break;
      case 'history': el.innerHTML = renderHistoryTab(); break;
    }
    bindTableSort();
    bindExpandables();
  }

  // --- Tests Tab ---
  function renderTestsTab() {
    let tests = [...run.tests];
    tests = applyFilters(tests);
    tests = applySorting(tests);
    if (tests.length === 0) return '<div class="empty-state">No tests match the current filters.</div>';
    return '<table><thead><tr>' +
      th('Status', 'status') + th('Test', 'title') + th('File', 'file') +
      th('Duration', 'duration') + th('Project', 'project') +
      '</tr></thead><tbody>' +
      tests.map(renderTestRow).join('') +
      '</tbody></table>';
  }

  function renderTestRow(t) {
    const badge = statusBadge(t);
    const errors = (t.errors && t.errors.length > 0)
      ? '<div class="details">' + t.errors.map(e => '<div class="error-pre">' + esc(e.message) + (e.stack ? '\\n\\n' + esc(e.stack) : '') + '</div>').join('') + '</div>'
      : '';
    const attachments = (t.attachments && t.attachments.length > 0 && artifactBaseUrl)
      ? '<div class="details">' + t.attachments.map(a => '<a href="' + artifactBaseUrl + '/' + a.path + '" target="_blank">' + esc(a.name) + '</a> ').join('') + '</div>'
      : '';
    const expandable = (errors || attachments) ? ' expandable' : '';
    return '<tr class="' + expandable + '" onclick="this.classList.toggle(\\'open\\')">' +
      '<td>' + badge + '</td>' +
      '<td><span class="test-title">' + esc(t.title) + '</span>' + errors + attachments + '</td>' +
      '<td class="file-path">' + esc(t.file) + '</td>' +
      '<td class="duration">' + fmtDur(t.duration) + '</td>' +
      '<td>' + esc(t.project) + '</td>' +
      '</tr>';
  }

  // --- Error Clusters Tab ---
  function renderErrorsTab() {
    if (errorClusters.length === 0) return '<div class="empty-state">No error clusters found. All tests passed! üéâ</div>';
    return '<h2>Error Clusters (' + errorClusters.length + ')</h2>' +
      errorClusters.map(c =>
        '<div class="cluster-card">' +
        '<h3>' + esc(c.message.slice(0, 200)) + '</h3>' +
        '<div class="cluster-meta">' + c.count + ' test(s) affected ¬∑ Files: ' + c.files.map(esc).join(', ') + '</div>' +
        (c.exampleStack ? '<div class="error-pre">' + esc(c.exampleStack) + '</div>' : '') +
        '</div>'
      ).join('');
  }

  // --- Shards Tab ---
  function renderShardsTab() {
    const shardMap = {};
    for (const t of run.tests) {
      const idx = t.shardIndex || 1;
      if (!shardMap[idx]) shardMap[idx] = { tests: [], duration: 0 };
      shardMap[idx].tests.push(t);
      shardMap[idx].duration += t.duration;
    }
    const shards = Object.keys(shardMap).sort((a,b) => +a - +b);
    if (shards.length <= 1 && run.shardCount <= 1) return '<div class="empty-state">Single shard ‚Äî no distribution to visualize.</div>';

    const maxDur = Math.max(...shards.map(s => shardMap[s].duration), 1);

    let html = '<h2>Shard Distribution</h2><div class="shard-bar-container">';
    for (const s of shards) {
      const pct = Math.max((shardMap[s].duration / maxDur) * 100, 2);
      html += '<div class="shard-bar" style="height:' + pct + '%"><span class="bar-value">' + fmtDur(shardMap[s].duration) + '</span><span class="bar-label">Shard ' + s + '</span></div>';
    }
    html += '</div>';

    html += '<div class="shard-info">';
    for (const s of shards) {
      const sd = shardMap[s];
      const failed = sd.tests.filter(t => t.status === 'failed').length;
      const flaky = sd.tests.filter(t => t.isFlaky).length;
      html += '<div class="shard-card"><h4>Shard ' + s + '</h4>' +
        '<div class="shard-detail">' + sd.tests.length + ' tests ¬∑ ' + fmtDur(sd.duration) + '</div>' +
        (failed ? '<div class="shard-detail" style="color:var(--fail)">' + failed + ' failed</div>' : '') +
        (flaky ? '<div class="shard-detail" style="color:var(--flaky)">' + flaky + ' flaky</div>' : '') +
        '</div>';
    }
    html += '</div>';
    return html;
  }

  // --- Flaky Tab ---
  function renderFlakyTab() {
    const flaky = run.tests.filter(t => t.isFlaky);
    if (flaky.length === 0) return '<div class="empty-state">No flaky tests detected! ‚úÖ</div>';

    // If we have history, enrich with flakiness rate
    const histMap = {};
    for (const h of history) histMap[h.id] = h;

    return '<h2>Flaky Tests (' + flaky.length + ')</h2>' +
      '<table><thead><tr><th>Test</th><th>File</th><th>Retries</th><th>Duration</th>' +
      (history.length > 0 ? '<th>Flakiness Rate (30d)</th><th>Trend</th>' : '') +
      '</tr></thead><tbody>' +
      flaky.map(t => {
        const h = histMap[t.id];
        return '<tr><td class="test-title">' + esc(t.title) + '</td><td class="file-path">' + esc(t.file) + '</td>' +
          '<td>' + t.retries + '</td><td class="duration">' + fmtDur(t.duration) + '</td>' +
          (history.length > 0 ? '<td>' + (h ? (h.flakinessRate * 100).toFixed(1) + '%' : '‚Äî') + '</td><td>' + (h ? sparkline(h.lastDurations) : '‚Äî') + '</td>' : '') +
          '</tr>';
      }).join('') +
      '</tbody></table>';
  }

  // --- History Tab ---
  function renderHistoryTab() {
    if (history.length === 0) return '<div class="empty-state">No historical data available yet. History builds up after multiple runs.</div>';

    const sorted = [...history].sort((a,b) => b.failureRate - a.failureRate || b.flakinessRate - a.flakinessRate);

    return '<h2>Test History (' + history.length + ' tests tracked)</h2>' +
      '<table><thead><tr>' +
      '<th>Test</th><th>Runs</th><th>Pass</th><th>Fail</th><th>Flaky</th>' +
      '<th>Flakiness %</th><th>Failure %</th><th>Avg Duration</th><th>Trend</th>' +
      '</tr></thead><tbody>' +
      sorted.slice(0, 100).map(h =>
        '<tr><td><span class="test-title">' + esc(h.title) + '</span><br><span class="file-path">' + esc(h.file) + '</span></td>' +
        '<td>' + h.totalRuns + '</td>' +
        '<td class="pass">' + h.passCount + '</td>' +
        '<td class="fail">' + h.failCount + '</td>' +
        '<td class="flaky">' + h.flakyCount + '</td>' +
        '<td>' + (h.flakinessRate * 100).toFixed(1) + '%</td>' +
        '<td>' + (h.failureRate * 100).toFixed(1) + '%</td>' +
        '<td class="duration">' + fmtDur(h.avgDuration) + '</td>' +
        '<td>' + sparkline(h.lastDurations) + '</td>' +
        '</tr>'
      ).join('') +
      '</tbody></table>';
  }

  // --- Helpers ---
  function applyFilters(tests) {
    if (statusFilter === 'flaky') return tests.filter(t => t.isFlaky);
    if (statusFilter !== 'all') tests = tests.filter(t => t.status === statusFilter);
    if (searchQuery) {
      const q = searchQuery.toLowerCase();
      tests = tests.filter(t =>
        t.title.toLowerCase().includes(q) ||
        t.file.toLowerCase().includes(q) ||
        (t.errors && t.errors.some(e => e.message.toLowerCase().includes(q)))
      );
    }
    return tests;
  }

  function applySorting(tests) {
    const dir = sortDir === 'asc' ? 1 : -1;
    return tests.sort((a, b) => {
      const av = sortVal(a, sortKey);
      const bv = sortVal(b, sortKey);
      if (typeof av === 'number' && typeof bv === 'number') return (av - bv) * dir;
      return String(av).localeCompare(String(bv)) * dir;
    });
  }

  function sortVal(t, key) {
    if (key === 'status') {
      const order = { failed: 0, timedOut: 1, flaky: 2, passed: 3, skipped: 4 };
      return t.isFlaky ? order.flaky : (order[t.status] ?? 5);
    }
    return t[key] ?? '';
  }

  function th(label, key) {
    const arrow = sortKey === key ? (sortDir === 'asc' ? ' ‚ñ≤' : ' ‚ñº') : '';
    return '<th data-sort="' + key + '">' + label + '<span class="sort-arrow">' + arrow + '</span></th>';
  }

  function statusBadge(t) {
    if (t.isFlaky) return '<span class="badge badge-flaky">‚ö†Ô∏è Flaky</span>';
    switch (t.status) {
      case 'passed': return '<span class="badge badge-pass">‚úÖ Passed</span>';
      case 'failed': return '<span class="badge badge-fail">‚ùå Failed</span>';
      case 'timedOut': return '<span class="badge badge-timeout">‚è± Timeout</span>';
      case 'skipped': return '<span class="badge badge-skip">‚è≠Ô∏è Skipped</span>';
      default: return '<span class="badge">' + t.status + '</span>';
    }
  }

  function sparkline(durations) {
    if (!durations || durations.length < 2) return '‚Äî';
    const max = Math.max(...durations, 1);
    return '<span class="trend-spark">' +
      durations.map(d => '<span class="bar" style="height:' + Math.max(Math.round((d / max) * 20), 1) + 'px"></span>').join('') +
      '</span>';
  }

  function fmtDur(ms) {
    if (ms < 1000) return ms + 'ms';
    if (ms < 60000) return (ms / 1000).toFixed(1) + 's';
    const m = Math.floor(ms / 60000);
    const s = ((ms % 60000) / 1000).toFixed(0);
    return m + 'm ' + s + 's';
  }

  function esc(s) {
    if (!s) return '';
    return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
  }

  // --- Event Bindings ---
  function bindEvents() {
    // Tabs
    document.getElementById('tabs').addEventListener('click', e => {
      const tab = e.target.closest('.tab');
      if (!tab) return;
      currentTab = tab.dataset.tab;
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      tab.classList.add('active');

      // Show/hide controls based on tab
      const controls = document.querySelector('.controls');
      controls.style.display = (currentTab === 'tests') ? '' : 'none';

      renderContent();
    });

    // Search
    document.getElementById('search').addEventListener('input', e => {
      searchQuery = e.target.value;
      renderContent();
    });

    // Status filter
    document.getElementById('filter-status').addEventListener('change', e => {
      statusFilter = e.target.value;
      renderContent();
    });
  }

  function bindTableSort() {
    document.querySelectorAll('th[data-sort]').forEach(th => {
      th.addEventListener('click', () => {
        const key = th.dataset.sort;
        if (sortKey === key) {
          sortDir = sortDir === 'asc' ? 'desc' : 'asc';
        } else {
          sortKey = key;
          sortDir = 'asc';
        }
        renderContent();
      });
    });
  }

  function bindExpandables() {
    document.querySelectorAll('.expandable').forEach(row => {
      row.addEventListener('click', () => row.classList.toggle('open'));
    });
  }
})();
`;

function escapeHtml(str: string): string {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
}

